/**
 * @fileoverview Firestore Security Rules for Cupping Compass.
 *
 * Core Philosophy:
 * This ruleset employs a hybrid security model, balancing open access for
 * public data with strict ownership and shared access controls for user-specific
 * and collaborative content. It prioritizes user privacy and data integrity.
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profiles, accessible only to the
 *   authenticated user themselves.
 * - /sessions/{sessionId}: Stores cupping session data, accessible to session
 *   participants.
 * - /sessions/{sessionId}/evaluations/{evaluationId}: Stores individual evaluations
 *   within a session, accessible only to the evaluator.
 * - /invitations/{invitationId}: Stores invitations, accessible only to session participants.
 *
 * Key Security Decisions:
 * - Users can only read/write their own user documents.
 * - Cupping sessions are accessible to authorized participants.
 * - Evaluations are only accessible to the user who created them.
 * - Listing of sessions is public to allow discovery.
 * - Users can only be added to a session by an admin.
 *
 * Denormalization for Authorization:
 * - CuppingSession documents contain a `participantUids` array to simplify
 *   access control for session data and evaluations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile information.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their own profile.
     * @allow (get, update, delete) User with matching UID can access and modify their own profile.
     * @deny (create) User cannot create a profile with a mismatched UID.
     * @deny (get, update, delete) User cannot access or modify another user's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isOwner(userId) {
          return request.auth.uid == userId;
        }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to cupping session data.
     * @path /sessions/{sessionId}
     * @allow (get, list) Any authenticated user can view the list of sessions.
     * @allow (create) Any authenticated user can create a session.
     * @allow (update, delete) Only the session admin can modify or delete a session.
     * @deny (update, delete) Non-admins cannot modify or delete sessions.
     * @principle Enforces shared access for session participants and admin control.
     */
    match /sessions/{sessionId} {
        function isSignedIn() {
          return request.auth != null;
        }
       function isParticipant(sessionId) {
          return request.auth.uid in resource.data.participantUids;
        }

        function isAdmin(sessionId) {
          return request.auth.uid == resource.data.adminUid;
        }

      allow get: if isSignedIn();
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isAdmin(sessionId);
      allow delete: if isSignedIn() && isAdmin(sessionId);
    }

    /**
     * @description Controls access to individual evaluations within a session.
     * @path /sessions/{sessionId}/evaluations/{evaluationId}
     * @allow (get, list) Only the evaluator can access their own evaluations.
     * @allow (create) Only an authenticated user can create an evaluation for themself within a session.
     * @allow (update, delete) Only the evaluator can modify or delete their own evaluations.
     * @deny (create, update, delete) Users cannot create, modify, or delete evaluations belonging to others.
     * @principle Enforces document ownership for evaluations.
     */
    match /sessions/{sessionId}/evaluations/{evaluationId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isOwner(evaluationId) {
           return request.auth.uid == resource.data.userId;
        }
         function isExistingOwner(evaluationId) {
          return request.auth.uid == get(/databases/$(database)/documents/sessions/$(sessionId)/evaluations/$(evaluationId)).data.userId;
        }

      allow get: if isSignedIn() && isOwner(evaluationId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.userId;
      allow update: if isSignedIn() && isExistingOwner(evaluationId);
      allow delete: if isSignedIn() && isExistingOwner(evaluationId);
    }

    /**
     * @description Controls access to invitations for users to join sessions.
     * @path /invitations/{invitationId}
     * @allow (get) Anyone can get invitation.
     * @allow (create) Only session admins can create invitations.
     * @allow (update) Only session admins can update invitations.
     * @allow (delete) Only session admins can delete invitations.
     * @principle Restricts invitation management to session admins.
     */
    match /invitations/{invitationId} {
         function isSignedIn() {
          return request.auth != null;
        }

        function isAdmin(){
           return get(/databases/$(database)/documents/sessions/$(request.resource.data.sessionId)).data.adminUid == request.auth.uid;
        }
        allow get: if isSignedIn();
      allow list: if false;
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin() ;
      allow delete: if isSignedIn() && isAdmin();
    }
  }
}