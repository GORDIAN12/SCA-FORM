/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model where all
 * data is private to the user who created it. Access control is based on the
 * user's unique ID (`request.auth.uid`).
 *
 * Data Structure: The data is organized hierarchically under a top-level `users`
 * collection. Each user's data, including their cupping sessions and evaluations,
 * is stored under their own document path: `/users/{userId}/...`.
 * This structure is designed to be highly performant and secure, as it avoids
 * costly database lookups (`get()` calls) for authorization checks.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is explicitly granted.
 * - Authentication Required: No anonymous or public access is permitted. A user
 *   must be signed in to read or write any data.
 * - Strict Ownership: Users can only read, write, or query data that exists
 *   within their own `/users/{userId}` path. They cannot see or interact with
 *   data belonging to other users.
 * - Path-Based Security: Authorization is derived directly from the document path,
 *   comparing the `{userId}` wildcard to the authenticated user's ID. This is a
 *   simple, fast, and highly secure pattern.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing the ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document exists and the user is the owner.
     * CRITICAL: Used for all update and delete operations to prevent modifying
     * or deleting non-existent data.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the userId in the document body matches the owner's UID.
     * This ensures data integrity and prevents a user from creating data
     * that appears to belong to someone else.
     */
    function hasValidOwner(userId) {
      return request.resource.data.userId == userId;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Secures the user's root document. This allows a user to
     *   create and manage their own user profile document, but prevents
     *   access by others.
     * @path /users/{userId}
     * @allow (create) A new user (auth.uid: 'user123') creates their profile at `/users/user123`.
     * @deny (get) Another user (auth.uid: 'user456') tries to read the profile at `/users/user123`.
     * @principle Establishes a secure, user-owned data root.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
    
    /**
     * @description Secures a user's coffee evaluation documents. Only the user
     *   who owns the evaluation (as determined by the path) can manage it.
     * @path /users/{userId}/evaluations/{evaluationId}
     * @allow (list) A user (auth.uid: 'user123') lists all evaluations at `/users/user123/evaluations`.
     * @deny (get) Another user (auth.uid: 'user456') tries to read an evaluation at `/users/user123/evaluations/evalABC`.
     * @principle Enforces strict ownership for the evaluations collection.
     */
    match /users/{userId}/evaluations/{evaluationId} {
        allow get, list, delete: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidOwner(userId);
        allow update: if isOwner(userId);
    }
  }
}
